<?php
/* Use PAMI to communicate with the asterisk manager */
// modify include path
$pamiSrcDir = implode(DIRECTORY_SEPARATOR, array(sfConfig::get('sf_lib_dir'), 'vendor', 'PAMI', 'src', 'mg'));
ini_set('include_path', ini_get('include_path') . PATH_SEPARATOR . $pamiSrcDir);

// register the autoloader
require_once $pamiSrcDir . DIRECTORY_SEPARATOR . 'PAMI' . DIRECTORY_SEPARATOR . '/Autoloader/Autoloader.php';
\PAMI\Autoloader\Autoloader::register();

// we're only using the command action because we need to prune a realtime peer
// and this task has no dedicated action
use PAMI\Client\Impl\ClientImpl;
use PAMI\Message\Action\CommandAction;

/**
 * Phones
 *
 * This class has been auto-generated by the Doctrine ORM Framework
 *
 * @package    hekphone
 * @subpackage model
 * @author     Your name here
 * @version    SVN: $Id: Builder.php 7490 2010-03-29 19:53:27Z jwage $
 */
class Phones extends BasePhones
{
  private $resident = NULL;

  /**
   * Will execute "sip prune realtime peer <peername>" on the asterisk machine
   * denoted via asteriskAmiHost asteriskAmiPost asteriskAmiUsername & asteriskAmiPassword
   *
   * This way a cached realtime peer can be updated which is neccesary to apply
   * e.g. password, context, ... changes.
   *
   * @todo check wheter the action was successfully executed
   * @return bool false if the phone is non-SIP peer and thus cannot be pruned
   */
  public function pruneAsteriskPeer() {

      if($this->technology != 'SIP') {
        return false;
      }

      $options = array(
        'host' => sfConfig::get('asteriskAmiHost'),
        'port' => sfConfig::get('asteriskAmiPort'),
        'username' => sfConfig::get('asteriskAmiUsername'),
        'secret' => sfConfig::get('asteriskAmiPassword'),
        'connect_timeout' => 60,
        'read_timeout' => 60,
        'scheme' => 'tcp://' // PAMI documentation says: try tls: not working :/
      );

      $pamiClient = new ClientImpl($options);
      $pamiClient->open();
      $pruneResult = $pamiClient->send(new CommandAction('sip prune realtime peer '. $this->name));
      $pamiClient->close();

      return $pruneResult->isSuccess(); // returns true even if the "command" action did not give the proper result
  }

  /**
   * Returns the resident as Doctrine_Record associated with this room.
   * False if there's on resident living in the room
   */
  public function getResident() {
      if(is_null($this->resident)) {
          try {
              $this->resident = Doctrine_Core::getTable('Residents')->findByRoomNo($this->Rooms[0]->get('room_no'));
          } catch (Exception $e) {
              $this->resident = null;
          }
      }

      return $this->resident;
  }

  /**
   * Returns the defaultip of the Phone. This is used to generate the DHCP-Konfiguration.
   * There is no field defaultip in the phones table because it is only an aggregated
   * value. Asterisk_Sip has such a defaultip field and calculates the value directly
   * from the room number the telephone is in.
   *
   * @return string (ip)
   */
  public function getDefaultip() {
      $room = $this->Rooms[0];
      $extension = '1' . $room;

      return '192.168.' . substr($extension,1,1) . "." . (int)substr($extension,2,3);
  }

  /**
   * Returns the name of the phone (sip peer). This is used to generate the DHCP-Konfiguration.
   * see getDefaultip
   *
   * @return string (ip)
   */
  public function getName() {
      $extension = '1' . $this->Rooms[0];

      return $extension;
  }

  /**
   * Returns the SIP defaultuser of the phone (sip peer). Needed for the phoneConfiguration
   *
   * @return string (ip)
   */
  public function getDefaultuser() {
      $extension = '1' . $this->Rooms[0];

      return $extension;
  }

  /**
   * Returns the name of the phone (sip peer). This is used to generate the DHCP-Konfiguration.
   * see getDefaultip
   *
   * @return string (ip)
   */
  public function getCallerid() {
      $extension =  1 . $this->Rooms[0];
      $room = $this->Rooms[0];
      if($resident = $this->getResident()) {
          $callerid = $resident->getFirstName() . ' ' . $resident->getLastName() . ' (' . $room . ')';
      } else {
          $callerid = $extension;
      }

      return $callerid;
  }

  /**
   * Returns the extension of the phone (like 1400) if it's located in any room.
   * False if the room is not allocated to any room
   *
   * @return string
   */
  public function getExtension() {
      if(isset($this->Rooms[0])) {
        return $extension = "1" . $this->Rooms[0];
      } else {
        return false;
      }
  }

  /**
   * Returns the extension neccesair to call the phone as array
   * (Intended for use with asteriskExtensions->fromArray())
   * Creates voicemailbox for the resident associated with the phone if he activated it.
   *
   * @return array()
   */
  public function getExtensionsAsArray() {
      $context   = 'phones';
      $extensionPrefix = '8695';
      $resident = $this->getResident();

      /* Check wheter the phone is really in a room */
      if ( ! $extension = $this->getExtension()) {
          sfContext::getInstance()->getLogger()->warning('Failed to get extension of a phone (' . $this->get('id') . ') which is not in any room.');
          return false;
      }

      /* Prepare the mailbox if whished */
      if($resident && $resident['vm_active']) {
        $resident->createVoicemailbox();
      }

      /* Prepare the extensions entries */
      // Calls to the phone from the PSTN
      $n = 1;

      // we mark the call as internal call eventhough it comes from outside
      // this is no problem because the call is still an incoming call and
      // thus never gets billed. we thereby solve the problem that calls from
      // analog phones to sip-phones arent marked as internal
      $arrayExtensions[0] = array(
           'exten'        => $extensionPrefix . $extension,
           'priority'     => $n++,
           'context'      => $context,
           'app'          => 'Set',
           'appdata'      => 'CDR(userfield)=internal'
      );

      $arrayExtensions[1] = array(
           'exten'        => $extensionPrefix . $extension,
           'priority'     => $n++,
           'context'      => $context,
           'app'          => 'Dial',
           'appdata'      => $this->getDialstring()
      );


      // include redirection of calls before the mailbox picks up
      if ($resident && $resident['redirect_active'] && $this['technology'] == 'SIP')
      {
          $residentsContext = ($resident['unlocked'])? 'unlocked' : 'locked';
          $arrayExtensions[2] = array(
              'exten'        => $extensionPrefix . $extension,
              'priority'     => $n++,
              'context'      => $context,
              'app'          => 'GoTo',
              'appdata'      => $residentsContext . sfConfig::get('asteriskParameterSeparator')
                              . $resident['redirect_to']  . sfConfig::get('asteriskParameterSeparator')
                              . '1'
          );
      }

      // include forwarding to mailbox if the resident turned on the vm
      if ($resident && $resident['vm_active'] && $this['technology'] == 'SIP')
      {
          $arrayExtensions[3] = array(
              'exten'        => $extensionPrefix . $extension,
              'priority'     => $n++,
              'context'      => $context,
              'app'          => 'Voicemail',
              'appdata'      => $resident['id'] . '@default'
          );
      }

      // hangup after the call finished
      $arrayExtensions[4] = array(
          'exten'        => $extensionPrefix . $extension,
          'priority'     => 99,
          'context'      => $context,
          'app'          => 'Hangup',
          'appdata'      => ''
      );


      // Calls to the phone from other sip phones
      $arrayExtensions[5] = array(
           'exten'        => $extension,
           'priority'     => 1,
           'context'      => $context,
           'app'          => 'GoTo',
           'appdata'      => $context . sfConfig::get('asteriskParameterSeparator')
                           . $extensionPrefix . $extension . sfConfig::get('asteriskParameterSeparator')
                           . '1' //Goto(context,extension,priority)
      );

      return $arrayExtensions;
  }

  /**
   * Gets the string for the appdata of the Dial command of asterisk for the phone
   * consideres redirections and voicemail
   * @return string
   */
  public function getDialstring() {
      $extension = $this->getExtension();
      $extensionPrefix = '8695';

      $dialstring = '';
      if ($this['technology'] == 'SIP') {
          $dialstring = $this['technology'] . '/' . $extension;
      } elseif($this['technology'] == 'DAHDI/g1') {
          $dialstring = $this['technology'] . '/' . $extensionPrefix . $extension;
      }

      $resident = $this->getResident();
      // redirect or call voicemailbox after the specified time period
      if ($resident != false && $resident['redirect_active']) {
          $dialstring .= sfConfig::get('asteriskParameterSeparator') . $resident['redirect_seconds'];
      } elseif($resident != false && $resident['vm_active']) {
          $dialstring .= sfConfig::get('asteriskParameterSeparator') . $resident['vm_seconds'];
      }

      return $dialstring;
  }

   /**
    * if a resident is living in the room of the phone use the appropriate
    * details: name, room_no as display name and the first 7 characters of
    * the residents password hash as sip password
    * @return Sip password
    */
  private function getSipPassword() {
    
      if(!$this->getResident() || '' == $this->getResident()->get('password')){
          return 'hekphone';
      }
      return substr($this->getResident()->getPassword(), 0 ,7);

  }


  /**
   * Create and save a configuration file for the phone that can be uploaded and be
   * used to reset a tiptel 83 VoIP phone.
   *
   * @param $overwritePersonalSettings bool Wheter to overwrite the phone book, short dial, ...
   * @return string
   */
  public function createPhoneConfigFile($overridePersonalSettings = false)
  {
      sfProjectConfiguration::getActive()->loadHelpers("Partial");
      $configFileContent = get_partial('global/tiptel83PhoneConfiguration', array('ip' => $this['defaultip'],
          'sip1PhoneNumber' => $this->getName(),
          'sip1DisplayName' => $this->getCallerid(),
          'sip1User' => $this->getDefaultuser(),
          'sip1Pwd' => $this->getSipPassword(),
          'overridePersonalSettings' => $overridePersonalSettings,
          'frontendPassword' => $this->getWebInterfacePassword()));

      $folder     = sfConfig::get("sf_data_dir") . DIRECTORY_SEPARATOR . "phoneConfigs" . DIRECTORY_SEPARATOR;
      $filepath   = $folder . $this->getName() . "-config.txt";
      $filehandle = fopen($filepath, "w+");
      if( ! fwrite($filehandle, $configFileContent))
      {
          throw new Exception("Could not write config file to $filepath");
      } else {
          return $filepath;
      }
	}

  /**
   * Reset configuration of phone
   * @param bool $overwritePersonalSettings Wheter to overwrite the phone book, short dial, ...
   * @param bool $createNewWebInterfacePassword True if web interface password should be changed
   */
  public function resetConfiguration($overwritePersonalSettings, $createNewWebInterfacePassword = false) {
    $password = $this->getWebInterfacePassword();
    $username = 'admin';
    if ($createNewWebInterfacePassword || $this->getWebInterfacePassword() == 'admin')
    {
        $this->setNewWebInterfacePassword();
    }

    $this->uploadConfiguration($overwritePersonalSettings, $username, $password);
    $this->pruneAsteriskPeer();
    $this->save();
  }

  /**
   * Generate and set new password for phone web interface
   */
  private function setNewWebInterfacePassword() {
     
    $token = 'abcdefghjkmnpqrstuvz123456789';

    $password = '';
    for ($i = 0; $i < 7; $i++)
    {
        $password .= $token[(rand() % strlen($token))];
    }

    return $this->setWebInterfacePassword($password);   
  }

  private function getManufacturerSpecificPartOfMac() {
    if('' === $this->getMac()) {
      return Null; 
    }
    return strToUpper(substr($this->getMac(), 0, 8)); // "12:45:78:##:##:##" -> "12:45:78"
  }

  /**
   * Generate and upload a configuration to the phone at $this->defaultip
   * via HTTP.
   *
   *  @param $overwritePersonalSettings bool Wheter to overwrite the phone book, short dial, ...
   */
  private function uploadConfiguration($overwritePersonalSettings = false, $username, $password) {
      if($this['technology'] != 'SIP')
      {
        throw new Exception("Can't upload configuration to analog Phone");
      }
    
      switch($this->getManufacturerSpecificPartOfMac()) {
        case sfConfig::get('tiptelMac');
          return $this->uploadConfigurationToTiptelPhone($overwritePersonalSettings, $username, $password) ;
        case sfConfig::get('grandstreamMac');
          return $this->uploadConfigurationToGrandstreamPhone($overwritePersonalSettings, $password) ;
        default:
          throw new Exception("Can't upload configuration to unsupported phone according to its MAC-address.");
      }
  }

  
    /**
     * Generate and upload a configuration to the phone from grandstrem at $this->defaultip
     * via HTTP.
     *
     *  @param $overwritePersonalSettings bool Wheter to overwrite the phone book, short dial, ...
     */
    private function uploadConfigurationToGrandstreamPhone($overwritePersonalSettings = false, $password) {

        /* Authenticate with the phone */
        $authCookie = $this->authenticateToGrandstreamPhone($password);

        /* Set Configuration */
        $this->updateSipAccountOfGrandstreamPhone($authCookie);
        $this->updateBasicSettingsOfGrandstreamPhone($authCookie);
        $this->updateAdvancedSettingsOfGrandstreamPhone($authCookie);

        /* Restart phone */
        $this->restartGrandstreamPhone($authCookie);

        return true;

    }

    /**
      * Sets the curl options for the webinterface of the grandstream phone
      */
    private function setCurlOptionsForGrandstreamPhone($ch, $authCookie = Null, $path = '/update.htm') {
        
        $httpHeaders = array('Keep-Alive: 115', 'Connection: keep-alive');
        if(Null !== $authCookie) {
            $httpHeaders[] = 'Cookie: auth=' . $authCookie;
        }
        curl_setopt($ch, CURLOPT_HTTPHEADER, $httpHeaders);
        curl_setopt($ch, CURLOPT_URL, "http://" . $this->defaultip.$path);
        curl_setopt($ch, CURLOPT_TIMEOUT, 10);
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); // output to string
        curl_setopt($ch, CURLOPT_HEADER, 1); // include headers in the output
    
    }
      
    /**
      * Logs in as admin into the phone web_interface from grandstrem at $this->defaultip
      * via HTTP.
      *
      *  @param $password web interface password for the login
      *  @return auth cookie
      */
    private function authenticateToGrandstreamPhone($password) {

        $ch = curl_init();
        $this->setCurlOptionsForGrandstreamPhone($ch, Null, '/dologin.htm');

        curl_setopt($ch, CURLOPT_POSTFIELDS, 'P2=' . $password . '&Login=Login&gnkey=0b82');

        $loginResult = curl_exec($ch);
        $statusCode  = curl_getinfo($ch, CURLINFO_HTTP_CODE);
        curl_close($ch);
      
        // 200 OK
        if(200 !== $statusCode) {
            throw new Exception("Authentication to the phone via webfrontend at $this->defaultip failed. Returned status code: $statusCode");
        }

        if(preg_match('/Please try again/', $loginResult)) {
            throw new Exception("Authentication to the phone via webfrontend at $this->defaultip failed. Wrong password.");
        }

        //get the cookie and use new headers from now on
        preg_match('/^Set-Cookie: (.*?); Version=1; Path=\//m', $loginResult, $m);
        $authCookie = $m[1];

        return $authCookie;

    }


    /**
      * Restarts the phone if it is from grandstream at $this->defaultip
      * via HTTP.
      *
      *  @param $authCookie
      */
    private function restartGrandstreamPhone($authCookie) {
       
        $ch = curl_init();
        $this->setCurlOptionsForGrandstreamPhone($ch, $authCookie, '/rs.htm');

        $Result     = curl_exec($ch);
        $statusCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
        curl_close($ch);

        // 200 OK
        if(200 !== $statusCode) {
            throw new Exception("Restart of the phone via webfrontend at $this->defaultip failed. Returned status code: $statusCode");
        }

    }

    /**
      * Update the sip account via the web_interface of the grandstrem phone at $this->defaultip
      * via HTTP.
      *
      *  @param $authCookie
      */
    private function updateSipAccountOfGrandstreamPhone($authCookie) {

        $ch = curl_init();
        $this->setCurlOptionsForGrandstreamPhone($ch, $authCookie);
     
        // Display name on phone
        $resident = $this->getResident();
        if(false != $resident) {
            $name = (string)$resident;
        } else {
            $name = 'HEKphone';
        }

        curl_setopt($ch, CURLOPT_POSTFIELDS, utf8_decode('P271=1&P270=' . $name . '&P47=192.168.255.254&P48=&P35=' . $this->getDefaultuser() .'&P36=' . $this->getDefaultuser() .'&P34='. $this->getSipPassword() . '&P3=&P103=0&P63=0&P31=1&P81=0&P288=0&P32=60&P40=5060&P138=20&P209&P250&P130=1&P131=0&P52=1&P99=0&P1346=0&P136=0&P188=0&P197=&P33=&P73=8&P29=0&P66=&P1347=**&P139=20&P191=1&P182=0&P260=180&P261=90&P262=0&P263=0&P264=0&P266=0&P267=1&P265=0&P272=0&P104=3&P1328=60&P65=0&P268=0&P129=0&P90=0&P298=0&P299=0&P258=0&P135=0&P137=0&P57=0&P58=8&P59=4&P60=18&P61=2&P62=98&P46=9&P98=3&P183=0&P134=&P198=100&update=Update&gnkey=0b82'));

        curl_exec($ch);
        $statusCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
        curl_close($ch);

        // 200 OK
        if(200 !== $statusCode) {
            throw new Exception("Update of SipAccount via webfrontend at $this->defaultip failed. Returned status code: $statusCode");
        }

    }

    /**
      * Update the advanced settings via the web_interface of the grandstrem phone at $this->defaultip
      * via HTTP. (for example updating the web interface password)
      *
      *  @param $authCookie
      */
    private function updateAdvancedSettingsOfGrandstreamPhone($authCookie) {

        $ch = curl_init();
        $this->setCurlOptionsForGrandstreamPhone($ch, $authCookie);

        curl_setopt($ch, CURLOPT_POSTFIELDS, utf8_decode('P2=' . $this->getWebInterfacePassword() . '&P49=0&P97=0&P96=97&P50=0&P37=2&P38=48&P51=0&P87=0&P1351=0&P1352=0&P1353=0&P85=4&P72=1&P39=5004&P78=0&P84=20&P101=&P76=&P212=1&P192=fm.grandstream.com/gs&P237=fm.grandstream.com/gs&P232=&P233=&P234=&P235=&P145=1&P194=0&P193=10080&P238=0&P240=0&P330=0&P331=&P332=0&P333=0&P1304=&P340=0&P1349=0&P1343=0&P341=&P71=&P79=101&P207=&P208=0&P30=192.168.255.254&P144=0&P105=&P106=&P107=&P345=f1=440,f2=480,c=200/400&#59;&P343=f1=350,f2=440&#59;&P344=f1=350,f2=440,c=\'1\'0/10&#59;&P346=f1=440,f2=480,c=200/400&#59;&P347=f1=440,f2=440,c=25/525&#59;&P348=f1=480,f2=620,c=50/50&#59;&P349=f1=480,f2=620,c=25/25&#59;&P91=0&P186=0&P1310=0&P184=0&P1311=0&P88=1&P1339=0&P1340=0&P1341=0&P1350=0&P1357=0&P1358=0&P1301=0&P1302=0&P342=0&P399=&update=Update&gnkey=0b82'));

        curl_exec($ch);
        $statusCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
        curl_close($ch);

        // 200 OK
        if(200 !== $statusCode) {
            throw new Exception("Uptdate of advanced settings via webfrontend at $this->defaultip failed. Returned status code: $statusCode");
        }

    }
    
    /**
      * Update the basic settings via the web_interface of the grandstrem phone at $this->defaultip
      * via HTTP. (for example updating the web interface password)
      *
      *  @param $authCookie
      */
    private function updateBasicSettingsOfGrandstreamPhone($authCookie) {

        $ch = curl_init();
        $this->setCurlOptionsForGrandstreamPhone($ch, $authCookie);

        curl_setopt($ch, CURLOPT_POSTFIELDS, utf8_decode('P196=&P8=0&P82=&P83=&P146=&P147=&P148=Grandstream GXP2000&P92=0&P93=0&P94=0&P95=0&P9=192&P10=168&P11=0&P12=160&P13=0&P14=0&P15=0&P16=0&P17=0&P18=0&P19=0&P20=0&P21=0&P22=0&P23=0&P24=0&P25=0&P26=0&P27=0&P28=0&P323=0&P301=0&P324=0&P304=0&P305=&P306=&P325=0&P307=0&P308=&P309=&P326=0&P310=0&P311=&P312=&P327=0&P313=0&P314=&P315=&P328=0&P316=0&P317=&P318=&P329=0&P319=0&P320=&P321=&P64=780&P143=0&P75=1&P246=3,-1,7,2,0;10,-1,7,3,0;60&P334=4&P335=0&P1329=10&P122=1&P102=2&P123=0&P338=0&P336=0&P351=0&update=Update&gnkey=0b82'));

        curl_exec($ch);
        $statusCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
        curl_close($ch);

        // 200 OK
        if(200 !== $statusCode) {
            throw new Exception("Uptdate of basic settings via webfrontend at $this->defaultip failed. Returned status code: $statusCode");
        }

    }
      
      
  /**
   * Generate and upload a configuration to the phone from tiptel at $this->defaultip
   * via HTTP.
   *
   *  @param $overwritePersonalSettings bool Wheter to overwrite the phone book, short dial, ...
   */
  private function uploadConfigurationToTiptelPhone($overwritePersonalSettings = false, $username, $password) {

      /* Authenticate with the phone */
      $authCookie = $this->curlInit();
      $authCookie = $this->curlLogIn($authCookie, $username, $password);

      /* Generate configuration file and get the path */
      $configurationFilePath = $this->createPhoneConfigFile($overwritePersonalSettings);

      /* Upload the configuration */
      $ch = curl_init();
      $httpHeaders = array(
          'Keep-Alive: 115',
          'Connection: keep-alive',
          'Cookie: auth=' . $authCookie);
      curl_setopt($ch, CURLOPT_HTTPHEADER, $httpHeaders);
      curl_setopt($ch, CURLOPT_URL, "http://" . $this->defaultip . '/directupdate.htm ');
      curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);

      $uploadPostData = array(
          'System' => '@' . $configurationFilePath,
          'WebUpdate' => 'Ãœbertragen',);
      curl_setopt($ch, CURLOPT_POSTFIELDS, $uploadPostData);

      $uploadResult = curl_exec($ch);

      if(strpos($uploadResult, "ok post") === false) {
        throw new Exception("Uploading the configuration file failed.");
      }

      return true;
  }

  /**
   * Connects to the phone at $this->defaultip to get an authentication cookie
   *
   * @return string authentication cookie
   */
  private function curlInit() {
      $sendAuthCookie = 'c0a900010000009b';
      $httpHeaders = array(
          'Keep-Alive: 115',
          'Connection: keep-alive',
          'Cookie: auth=' . $sendAuthCookie);

      /* Get the front page to get an authentication cookie in return */
      $ch = curl_init();
      curl_setopt($ch, CURLOPT_HTTPHEADER, $httpHeaders);
      curl_setopt($ch, CURLOPT_URL, "http://" . $this->defaultip);
      curl_setopt($ch,CURLOPT_TIMEOUT, 10);
      //curl_setopt($ch, CURLOPT_VERBOSE, TRUE);
      curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); // output to string
      curl_setopt($ch, CURLOPT_HEADER, 1); // include headers in the output

      if( ! $loginPageContent = curl_exec($ch) ) {
          throw new Exception("Unable to connect to a phone at $this->defaultip");
      }


      //get the cookie and use new headers from now on
      preg_match('/^Set-Cookie: auth=(.*?);/m', $loginPageContent, $m);
      $newAuthCookie = $m[1];
      curl_close($ch);

      return $newAuthCookie;
  }

  /**
   * Sends the $username/$password to the phone to log in. Session is bound to the
   * authentication cookie you provide via $authCookie. Authentication cookie needs
   * to be generated via $this->curlInit().
   *
   * @param string $authCookie
   * @param string $username
   * @param string $password
   * @return string authentication cookie
   */
  private function curlLogIn($authCookie, $username, $password) {
      $httpHeaders = array(
          'Keep-Alive: 115',
          'Connection: keep-alive',
          'Cookie: auth=' . $authCookie);

      $ch = curl_init();
      curl_setopt($ch, CURLOPT_HTTPHEADER, $httpHeaders);
      curl_setopt($ch, CURLOPT_URL, "http://" . $this->defaultip);
      //curl_setopt($ch, CURLOPT_VERBOSE, TRUE);
      curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);

      // the sort order of the parameters MATTERS!
      //$loginPostData  = 'username' . '=' . $username . '&'; // we don't need to transfer the username and password the phone
      //$loginPostData .= 'password' . '=' . $password . '&'; // expects the username and a salted password hash as encoded field instead
      $loginPostData  = 'encoded'  . '=' . $username . '%3A' . md5($username . ':' . $password . ':' . $authCookie) . '&';
      $loginPostData .= 'nonce'    . '=' . $authCookie . '&';
      $loginPostData .= 'goto'     . '=' . 'OK' . '&';
      $loginPostData .= 'URL'      . '=' . '%2F';

      curl_setopt($ch, CURLOPT_POSTFIELDS, $loginPostData);

      $loginResult = curl_exec($ch);
      if(strpos($loginResult, "503 Server Busy") !== false) {
        throw new Exception("Login on the phones webfrontend at $this->defaultip failed. 'Server Busy' restart it manually then try again.");
      }

      if(strpos($loginResult, "PHONE CONFIG") === false) {
        throw new Exception("Login on the phones webfrontend at $this->defaultip failed");
      }

      return $authCookie;
  }

}
